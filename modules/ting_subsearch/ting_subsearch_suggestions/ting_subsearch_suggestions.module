<?php

/**
 * @file
 * Ting subsearch suggestions module file.
 */

// The Max number of chars supported by PHP's levenshtein algorithm.
define('TING_SUBSEARCH_SUGGESTIONS_LEVENSHTEIN_LIMIT', 255);

/**
 * Implements hook_ting_subsearch_info().
 */
function ting_subsearch_suggestions_ting_subsearch_info() {
  $trigger_settings = [];

  // Trigger settings.
  $trigger_settings['ting_subsearch_suggestions_distance'] = [
    '#type' => 'textfield',
    '#title' => t('Maximum Levenshtein distance'),
    '#default_value' => variable_get('ting_subsearch_suggestions_distance', 3),
    '#description' => t('The maximum Levenshtein distance between a suggestion and the user search for it to be used in a subsearch and possibly shown as a suggestion to the user. A higher numbere allows for less similar words to be suggested.'),
    '#element_validate' => ['element_validate_integer_positive'],
  ];
  $trigger_settings['ting_subsearch_suggestions_trigger_limit'] = [
    '#type' => 'textfield',
    '#title' => t('Maximum number of results for user search'),
    '#default_value' => variable_get('ting_subsearch_suggestions_trigger_limit', 5),
    '#description' => t("If the user search returned more results than this don't bother trying to find a suggestion and perform subsearch."),
    '#element_validate' => ['element_validate_integer_positive'],
  ];
  $trigger_settings['ting_subsearch_suggestions_ps_factor'] = [
    '#type' => 'textfield',
    '#title' => t('Minimum ratio between suggestion and user search results'),
    '#default_value' => variable_get('ting_subsearch_suggestions_ps_factor', 10),
    '#description' => t('The minimum ratio between suggestion and user search results to trigger suggestion. Use a decimal value for the ratio with "." as decimal separator'),
    '#element_validate' => ['ting_subsearch_factor_field_validate'],
  ];
  $trigger_settings['ting_subsearch_suggestions_message_limit'] = [
    '#type' => 'textfield',
    '#title' => t('Minimum number of results for suggestion search'),
    '#default_value' => variable_get('ting_subsearch_suggestions_message_limit', 10),
    '#description' => t("If the suggestion subsearch returned less results than this don't bother showing a suggestion."),
    '#element_validate' => ['element_validate_integer_positive'],
  ];
  // Insert notice about the zero-hit special case for this module.
  $trigger_settings['zero_hit_notice'] = [
    '#type' => 'item',
    '#title' => t('NOTICE: Special case if user search returned 0 results.'),
    '#description' => t('If the user search returned 0 results, an attempt to find a suggestion within acceptable Levenshtein distance will always be performed. If the suggestion has a non-empty search result a redirect to that subsearch will be performed. This is done regardless of the trigger conditions.'),
  ];

  return [
    'ting_subsearch_suggegtions' => [
      'title' => t('Ting subsearch suggestions'),
      'description' => t('Trigger subsearches based on autocomplete suggestions and levenshtein distance.'),
      'trigger_settings' => $trigger_settings,
      'settings' => [],
    ],
  ];
}

/**
 * Implements hook_ting_subsearch_ajax_callback().
 */
function ting_subsearch_suggestions_ting_subsearch_ajax_callback($original_search, $original_search_num_results) {
  $message = '';

  if (!$suggestion = ting_subsearch_suggestions_suggest_keys($original_search)) {
    return $message;
  }

  // Do a secondary search with the suggested keys and check if it satisfies
  // conditions.
  $suggestion_result = ting_subsearch_do_secondary_search($suggestion);
  $suggestion_num_results = $suggestion_result->getNumTotalObjects();

  $limit = variable_get('ting_subsearch_suggestions_message_limit', 10);
  $factor = variable_get('ting_subsearch_suggestions_ps_factor');

  if ($suggestion_num_results >= $limit && $suggestion_num_results / $original_search_num_results >= $factor) {
    $message = t('Search for <strong>"@suggestion"</strong> - returns <strong>!suggestion-num-results</strong> hits', [
      '@suggestion' => $suggestion,
      '!suggestion-num-results' => $suggestion_num_results,
    ]);
    $message = theme('ting_subsearch_message', [
      'message' => l($message, 'search/ting/' . $suggestion, [
        'html' => TRUE,
        'attributes' => ['target' => 'blank'],
        'query' => ting_subsearch_get_query_parameters(),
      ]),
      'type' => 'suggestions',
      'suggestion' => $suggestion,
      'suggestion_num_results' => $suggestion_num_results,
      'original_search' => $original_search,
      'original_search_num_results' => $original_search_num_results,
    ]);
  }

  return $message;
}

/**
 * Implements hook_ting_search_results_prefix().
 */
function ting_subsearch_suggestions_ting_search_results_prefix($keys, $conditions, $results) {
  $original_search_num_results = $results->getNumTotalObjects();

  // It it's a zero hit search we immediatly look for a suggestion and do
  // secondary search and redirect if the new search returned any results.
  if ($original_search_num_results == 0) {
    $suggestion = ting_subsearch_suggestions_suggest_keys($keys);

    if ($suggestion) {
      $suggestion_result = ting_subsearch_do_secondary_search($suggestion);

      if ($suggestion_result->getNumTotalObjects() > 0) {
        $query = [
          'original-search' => $keys,
        ] + ting_subsearch_get_query_parameters();

        drupal_goto('search/ting/' . $suggestion, ['query' => $query]);
      }
    }
  }

  $output = '';

  // If we're already redirecting from a zero-hit search avoid trying to find
  // suggestions for our own suggestion. Display a zero hit suggestions message.
  if (!empty($_GET['original-search'])) {
    $output = theme('ting_subsearch_message', [
      'message' => t('Showing results for <strong>"@suggestion"</strong>. The search for <strong>"@original_search"</strong> returned 0 hits.', [
        '@suggestion' => $keys,
        '@original_search' => $_GET['original-search'],
      ]),
      'type' => 'suggestions',
      'suggestion' => $keys,
      'suggestion_num_results' => $original_search_num_results,
      'original_search' => $_GET['original-search'],
      'original_search_num_results' => 0,
    ]);
  }
  // Otherwise trigger non-zero-hit seconday search if it's below limit.
  // For performance reasons we handel this with async AJAX request, since it's
  // not as critical as a zero-hit search.
  elseif ($original_search_num_results <= variable_get("ting_subsearch_suggestions_trigger_limit", 5)) {
    $output = theme('ting_subsearch_ajax_trigger', [
      'original_search' => $keys,
      'original_search_num_results' => $original_search_num_results,
      'module' => 'ting_subsearch_suggestions',
    ]);
  }

  return $output;
}

/**
 * Find the best suitable suggestion for the given original search.
 *
 * @param string $original_search
 *   The original search that you want to find suggestion for.
 *
 * @return string
 *   The suggestion or FALSE if it was not possible to find a suggestion within
 *   the configured constraints.
 *
 * @throws Exception
 */
function ting_subsearch_suggestions_suggest_keys($original_search) {
  if (!ding_provider_implements('search', 'autocomplete_suggestions')) {
    return FALSE;
  }

  $original_search = ting_subsearch_normalize_keys($original_search);

  if (strlen($original_search) > TING_SUBSEARCH_SUGGESTIONS_LEVENSHTEIN_LIMIT) {
    return FALSE;
  }

  // Build expected query object for provider hook.
  $query = [];
  $query['q'] = $original_search;
  $query['type'] = 'all';
  $suggestions = ding_provider_invoke('search', 'autocomplete_suggestions', $query);

  // We can't use the suggestions directly. For example author suggestions, will
  // often return something like "emelie schepp (f. 1979)". So we build
  // candidates word by word from the suggestions and consider them if they get
  // below acceptable levenshtein distance.
  $candidates = array_map(function ($suggestion) use ($original_search) {
    // Replace multiple spaces with single space. There might be typos in
    // bibliographic data.
    $suggestion = preg_replace('/\s+/', ' ', $suggestion);

    $keys = '';
    foreach (explode(' ', $suggestion) as $word) {
      $keys .= $word;

      // Exclude and move on to next suggestion if the candidate has grown over
      // char limit.
      if (strlen($keys) > TING_SUBSEARCH_SUGGESTIONS_LEVENSHTEIN_LIMIT) {
        return FALSE;
      }

      // Original search is already normalized, but we lower our current
      // candidate keys before comparison.
      $distance = ting_subsearch_suggestions_levenshtein($original_search, drupal_strtolower($keys));

      // It can happen that candidate will be the same as user search. In this
      // case we should continue adding words, since we might still hit one that
      // will be within acceptable distance.
      if ($distance == 0) {
        continue;
      }

      if ($distance <= variable_get('ting_subsearch_suggestions_distance', 3)) {
        return [
          'keys' => $keys,
          'distance' => $distance,
        ];
      }

      // Prepare for next word.
      $keys .= ' ';
    }

    // We could not build an acceptable candidate from the suggestion, so mark
    // it for exclusion.
    return FALSE;

  }, $suggestions);

  // Filter out suggestions marked for exclusion.
  $candidates = array_filter($candidates);

  // Sort for best candidates first.
  uasort($candidates, function ($candidate_a, $candidate_b) {
    return $candidate_a['distance'] - $candidate_b['distance'];
  });

  // Get the final suggestion.
  $suggestion = reset($candidates);

  if (!empty($suggestion)) {
    return $suggestion['keys'];
  }
  return FALSE;
}

/**
 * Wrapper around PHP's levenshtein that handles multibyte encodings correctly.
 *
 * PHP's levenshtein function processes each byte of the input string
 * individually which can give incorrect results in some cases. E.g. the
 * distance from "ol" to "øl" would be 2.
 *
 * This wrapper uses an approach where non-ascii characters are remapped to
 * the range [128-255] in order of appearance. Thus it supports up to 128
 * different multibyte code points max over the whole set of strings used in the
 * request and sharing this encoding.
 *
 * Based on: https://stackoverflow.com/a/26271822.
 */
function ting_subsearch_suggestions_levenshtein($str1, $str2) {
  $str1 = _ting_subsearch_suggestions_utf8_to_ascii($str1);
  $str2 = _ting_subsearch_suggestions_utf8_to_ascii($str2);
  return levenshtein($str1, $str2);
}

/**
 * Convert an UTF-8 encoded string to a single-byte string for levenshtein.
 */
function _ting_subsearch_suggestions_utf8_to_ascii($str) {
  $ascii_strings = &drupal_static(__FUNCTION__ . '_strings');
  // Since we remember string we need to ensure we get consistent mapping
  // between calls in a request.
  $map = &drupal_static(__FUNCTION__ . '_map');

  if (!isset($ascii_strings[$str])) {
    // Find all multibyte characters (cf. utf-8 encoding specs).
    $matches = array();
    if (!preg_match_all('/[\xC0-\xF7][\x80-\xBF]+/', $str, $matches)) {
      // Plain ascii string.
      return $str;
    }

    // Update the encoding map with the characters not already met.
    foreach ($matches[0] as $mbc) {
      if (!isset($map[$mbc])) {
        $map[$mbc] = chr(128 + count($map));
      }
    }

    // Finally remap non-ascii characters.
    $ascii_strings[$str] = strtr($str, $map);
  }

  return $ascii_strings[$str];
}
