<?php

/**
 * @file
 * Ding SEO module file.
 */

 define('DING_SEO_EMPTY_PIVOT_VALUE', '|EMPTY|');
 define('DING_SEO_COMMA_PIVOT_VALUE', '|COMMA|');

/**
 * Implements hook_metatag_metatags_view_alter().
 *
 * Schema metatag uses commas as delimiter for multiple values. This poses a
 * problem if one of our token values contains a comma. This is a known problem
 * with a proposed solution, but there's no patch for the Drupal 7 version.
 * There's also the issue with empty values which does not play nicely with the
 * pivot operation performed by schema metatag. For this issue there is a Drupal
 * 7 patch, but since we need to handle the comma issue anyway, we chose to
 * handle both in our alter and avoid the patch. An alternative solution would
 * be to submit our own Drupal 7 patch to the commma-issue.
 *
 * Comma issue: https://www.drupal.org/project/schema_metatag/issues/2988052
 * Empty values issue: https://www.drupal.org/project/metatag/issues/3067803
 */
function ding_seo_metatag_metatags_view_alter(&$output, $instance, $options) {
  foreach ($output as $metatag => $metatag_output) {
    if (!empty($output[$metatag]['#attached']['drupal_add_html_head'][0][0]['#attributes']['schema_metatag'])) {
      $content = &$output[$metatag]['#attached']['drupal_add_html_head'][0][0]['#attributes']['content'];
      if (is_array($content)) {
        $content = ding_seo_format_pivoted_values_recursive($content);
      }
    }
  }
}

/**
 * Format pivoted values recursively.
 *
 * @param $values
 *   Array of pivoted values from shema_metatag module.
 *
 * @return array
 *   The filtered array.
 */
function ding_seo_format_pivoted_values_recursive($values) {
  // Termination.
  if (!is_array($values)) {
    return $values;
  }
  // Recursive step.
  $values = array_map(function($value) {
    return ding_seo_format_pivoted_values_recursive($value);
  }, $values);

  $values = array_map(function($value) {
    // Mark empty values so they get filtered out below.
    if ($value === DING_SEO_EMPTY_PIVOT_VALUE) {
      return FALSE;
    }
    // Replace commas if single value string.
    if (is_string($value)) {
      $value = str_replace(DING_SEO_COMMA_PIVOT_VALUE, ',', $value);
    }
    return $value;
  }, $values);
  // Filter out the empty values.
  return array_filter($values);
}

/**
 * Implements hook_metatag_get_entity_metatags_instance_alter().
 *
 * Note: appearently this hook has to reside in module file and can not be in
 * ding_seo.metatag.inc. or else it will ONLY be called on first page load
 * after a cache clear. Investigate why this happens?
 */
function ding_seo_metatag_get_entity_metatags_instance_alter(&$instance, $entity, $entity_type, $bundle) {
  if ($entity_type == 'ting_object') {
    // Use simple material type checking for now to decide a ting objects schema
    // type. We will have to get more complex in the future, when we have to
    // distinguish between movies and tv-series for example. Also if we wish to
    // be provider independant we need a mechanism to avoid hard coded values.
    // For now this is opensearch speficic anb based and DKABM types:
    // http://www.danbib.dk/docs/abm/types.xml
    $material_type = drupal_strtolower($entity->getType());

    $schema_type_mapping = [
      'book' => [
        'bog',
        'bog stor skrift',
        'billedbog',
        'ebog',
        'lydbog (bånd)',
        'lydbog (cd)',
        'lydbog (net)',
        'lydbog (cd-mp3)',
        'årbog',
      ],
      'movie' => [
        'dvd',
        'dvd (film)',
        'blu-ray',
        'film',
        'film (net)',
      ]
    ];

    foreach ($schema_type_mapping as $schema_type => $material_types) {
      if (in_array($material_type, $material_types)) {
        $instance = 'ting_object:' . $schema_type;
        return;
      }
    }
  }
}

/**
 * Determine the schema.org bookFormat for a ting_object.
 *
 * We aim to support the format types supported by Google;
 * https://developers.google.com/search/docs/data-types/book#work-example
 *
 * @param $ting_object
 *   The ting_object to determine book format for.
 *
 * @return mixed
 *   One of the supported book format types as string. NULL if no book format
 *   could be determined for the $ting_object.
 */
function ding_seo_get_schema_book_format($ting_object) {
  $material_type = drupal_strtolower($ting_object->getType());

  $schema_book_format_mapping = [
    'EBook' => [
      'ebog'
    ],
    // TODO: Can differentiaie between Hardcove and Paperback?
    // For now use map all physical books to Hardcover.
    'Paperback' => [],
    'Hardcover' => [
      'bog',
      'bog stor skrift',
      'billedbog',
    ],
    'AudioBook' => [
      'lydbog (bånd)',
      'lydbog (cd)',
      'lydbog (net)',
      'lydbog (cd-mp3)',
    ],
  ];

  foreach ($schema_book_format_mapping as $book_format => $material_types) {
    if (in_array($material_type, $material_types)) {
      return $book_format;
    }
  }
  return NULL;
}
